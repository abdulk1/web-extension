var H=Object.defineProperty;var B=(t,e,r)=>e in t?H(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var c=(t,e,r)=>(B(t,typeof e!="symbol"?e+"":e,r),r);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const a of i.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function r(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(s){if(s.ep)return;s.ep=!0;const i=r(s);fetch(s.href,i)}})();function F(t){const e={d:{}};for(const r of Object.keys(t)){const n=t[r];if("file"in n){const i=n.file.contents,a=typeof i=="string"?i:V(i),o=typeof i=="string"?{}:{b:!0};e.d[r]={f:{c:a,...o}};continue}const s=F(n.directory);e.d[r]=s}return e}function V(t){let e="";for(const r of t)e+=String.fromCharCode(r);return e}var Y=Object.defineProperty,$=(t,e)=>{for(var r in e)Y(t,r,{get:e[r],enumerable:!0})},d={};$(d,{createEndpoint:()=>R,expose:()=>A,proxy:()=>q,proxyMarker:()=>L,releaseProxy:()=>D,transfer:()=>N,transferHandlers:()=>I,windowEndpoint:()=>Q,wrap:()=>U});var L=Symbol("Comlink.proxy"),R=Symbol("Comlink.endpoint"),D=Symbol("Comlink.releaseProxy"),P=Symbol("Comlink.thrown"),T=t=>typeof t=="object"&&t!==null||typeof t=="function",J={canHandle:t=>T(t)&&t[L],serialize(t){const{port1:e,port2:r}=new MessageChannel;return A(t,e),[r,[r]]},deserialize(t){return t.start(),U(t)}},G={canHandle:t=>T(t)&&P in t,serialize({value:t}){let e;return t instanceof Error?e={isError:!0,value:{message:t.message,name:t.name,stack:t.stack}}:e={isError:!1,value:t},[e,[]]},deserialize(t){throw t.isError?Object.assign(new Error(t.value.message),t.value):t.value}},I=new Map([["proxy",J],["throw",G]]);function A(t,e=self){e.addEventListener("message",function r(n){if(!n||!n.data)return;const{id:s,type:i,path:a}=Object.assign({path:[]},n.data),o=(n.data.argumentList||[]).map(w);let l;try{const u=a.slice(0,-1).reduce((f,_)=>f[_],t),h=a.reduce((f,_)=>f[_],t);switch(i){case 0:l=h;break;case 1:u[a.slice(-1)[0]]=w(n.data.value),l=!0;break;case 2:l=h.apply(u,o);break;case 3:{const f=new h(...o);l=q(f)}break;case 4:{const{port1:f,port2:_}=new MessageChannel;A(t,_),l=N(f,[f])}break;case 5:l=void 0;break}}catch(u){l={value:u,[P]:0}}Promise.resolve(l).catch(u=>({value:u,[P]:0})).then(u=>{const[h,f]=C(u);e.postMessage(Object.assign(Object.assign({},h),{id:s}),f),i===5&&(e.removeEventListener("message",r),j(e))})}),e.start&&e.start()}function K(t){return t.constructor.name==="MessagePort"}function j(t){K(t)&&t.close()}function U(t,e){return S(t,[],e)}function g(t){if(t)throw new Error("Proxy has been released and is not useable")}function S(t,e=[],r=function(){}){let n=!1;const s=new Proxy(r,{get(i,a){if(g(n),a===D)return()=>p(t,{type:5,path:e.map(o=>o.toString())}).then(()=>{j(t),n=!0});if(a==="then"){if(e.length===0)return{then:()=>s};const o=p(t,{type:0,path:e.map(l=>l.toString())}).then(w);return o.then.bind(o)}return S(t,[...e,a])},set(i,a,o){g(n);const[l,u]=C(o);return p(t,{type:1,path:[...e,a].map(h=>h.toString()),value:l},u).then(w)},apply(i,a,o){g(n);const l=e[e.length-1];if(l===R)return p(t,{type:4}).then(w);if(l==="bind")return S(t,e.slice(0,-1));const[u,h]=k(o);return p(t,{type:2,path:e.map(f=>f.toString()),argumentList:u},h).then(w)},construct(i,a){g(n);const[o,l]=k(a);return p(t,{type:3,path:e.map(u=>u.toString()),argumentList:o},l).then(w)}});return s}function X(t){return Array.prototype.concat.apply([],t)}function k(t){const e=t.map(C);return[e.map(r=>r[0]),X(e.map(r=>r[1]))]}var W=new WeakMap;function N(t,e){return W.set(t,e),t}function q(t){return Object.assign(t,{[L]:!0})}function Q(t,e=self,r="*"){return{postMessage:(n,s)=>t.postMessage(n,r,s),addEventListener:e.addEventListener.bind(e),removeEventListener:e.removeEventListener.bind(e)}}function C(t){for(const[e,r]of I)if(r.canHandle(t)){const[n,s]=r.serialize(t);return[{type:3,name:e,value:n},s]}return[{type:0,value:t},W.get(t)||[]]}function w(t){switch(t.type){case 3:return I.get(t.name).deserialize(t.value);case 0:return t.value}}function p(t,e,r){return new Promise(n=>{const s=Z();t.addEventListener("message",function i(a){!a.data||!a.data.id||a.data.id!==s||(t.removeEventListener("message",i),n(a.data))}),t.start&&t.start(),t.postMessage(Object.assign({id:s},e),r)})}function Z(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}const ee="https://stackblitz.com/headless";let b=null,E=null,v={};const te=new TextDecoder,re=new TextEncoder,m=class m{constructor(e,r,n){c(this,"_instance");c(this,"_runtimeInfo");c(this,"fs");c(this,"_tornDown",!1);this._instance=e,this._runtimeInfo=n,this.fs=new ce(r)}async spawn(e,r,n){let s=[];Array.isArray(r)?s=r:n=r;let i,a=new ReadableStream;if((n==null?void 0:n.output)!==!1){const u=me();i=u.push,a=u.stream}const o=z(ue(i)),l=await this._instance.run({command:e,args:s,env:n==null?void 0:n.env,terminal:n==null?void 0:n.terminal},void 0,void 0,o);return new oe(l,a)}on(e,r){let n=!1,s=()=>{};const i=(...a)=>{n||r(...a)};return this._instance.on(e,d.proxy(i)).then(a=>{s=a,n&&s()}),()=>{n=!0,s()}}mount(e,r){const n=e instanceof Uint8Array?e:e instanceof ArrayBuffer?new Uint8Array(e):re.encode(JSON.stringify(F(e)));return this._instance.loadFiles(d.transfer(n,[n.buffer]),{mountPoints:r==null?void 0:r.mountPoint})}get path(){return this._runtimeInfo.path}get workdir(){return this._runtimeInfo.cwd}teardown(){if(this._tornDown)throw new Error("WebContainer already torn down");this._tornDown=!0,this.fs._teardown(),this._instance.teardown(),this._instance[d.releaseProxy](),m._instance===this&&(m._instance=null)}static async boot(e={}){const{workdirName:r}=e;if(window.crossOriginIsolated&&e.coep==="none"&&console.warn(`A Cross-Origin-Embedder-Policy header is required in cross origin isolated environments.
Set the 'coep' option to 'require-corp'.`),r!=null&&r.includes("/")||r===".."||r===".")throw new Error("workdirName should be a valid folder name");for(;b;)await b;if(m._instance)throw new Error("Only a single WebContainer instance can be booted");const n=le(e);b=n.catch(()=>{});try{const s=await n;return m._instance=s,s}finally{b=null}}};c(m,"_instance",null);let x=m;const ne=1,se=2;class ie{constructor(e,r){c(this,"name");c(this,"_type");this.name=e,this._type=r}isFile(){return this._type===ne}isDirectory(){return this._type===se}}class ae{constructor(e,r,n,s){c(this,"_apiClient");c(this,"_path");c(this,"_options");c(this,"_listener");c(this,"_wrappedListener");c(this,"_watcher");c(this,"_closed",!1);this._apiClient=e,this._path=r,this._options=n,this._listener=s,this._apiClient._watchers.add(this),this._wrappedListener=(i,a)=>{this._listener&&!this._closed&&this._listener(i,a)},this._apiClient._fs.watch(this._path,this._options,z(this._wrappedListener)).then(i=>{this._watcher=i,this._closed&&this._teardown()}).catch(console.error)}close(){this._closed||(this._closed=!0,this._apiClient._watchers.delete(this),this._teardown())}_teardown(){var e;(e=this._watcher)==null||e.close().finally(()=>{var r;(r=this._watcher)==null||r[d.releaseProxy]()})}}class oe{constructor(e,r){c(this,"output");c(this,"input");c(this,"exit");c(this,"_process");this.output=r,this._process=e,this.input=new WritableStream({write:n=>{var s;(s=this._getProcess())==null||s.write(n).catch(()=>{})}}),this.exit=this._onExit()}kill(){var e;(e=this._getProcess())==null||e.kill()}resize(e){var r;(r=this._getProcess())==null||r.resize(e)}async _onExit(){var e;try{return await this._process.onExit}finally{(e=this._process)==null||e[d.releaseProxy](),this._process=null}}_getProcess(){return this._process==null&&console.warn("This process already exited"),this._process}}class ce{constructor(e){c(this,"_fs");c(this,"_watchers",new Set([]));this._fs=e}rm(...e){return this._fs.rm(...e)}async readFile(e,r){return await this._fs.readFile(e,r)}async rename(e,r){return await this._fs.rename(e,r)}async writeFile(e,r,n){if(r instanceof Uint8Array){const s=r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength);r=d.transfer(new Uint8Array(s),[s])}await this._fs.writeFile(e,r,n)}async readdir(e,r){const n=await this._fs.readdir(e,r);return de(n)||he(n)?n:n.map(i=>new ie(i.name,i["Symbol(type)"]))}async mkdir(e,r){return await this._fs.mkdir(e,r)}watch(e,r,n){return typeof r=="function"&&(n=r,r=null),new ae(this,e,r,n)}_teardown(){this._fs[d.releaseProxy]();for(const e of this._watchers)e.close()}}async function le(t){const{serverPromise:e}=fe(t),n=await(await e).build({host:window.location.host,version:"1.1.9",workdirName:t.workdirName}),s=await n.fs(),i=await n.runtimeInfo();return new x(n,s,i)}function ue(t){if(t!=null)return e=>{e instanceof Uint8Array?t(te.decode(e)):e==null&&t(null)}}function z(t){if(t!=null)return d.proxy(t)}function fe(t){if(E!=null)return t.coep!==v.coep&&(console.warn(`Attempting to boot WebContainer with 'coep: ${t.coep}'`),console.warn(`First boot had 'coep: ${v.coep}', new settings will not take effect!`)),{serverPromise:E};const e=document.createElement("iframe");e.style.display="none",e.setAttribute("allow","cross-origin-isolated");const r=we();r.searchParams.set("version","1.1.9"),t.coep&&r.searchParams.set("coep",t.coep),e.src=r.toString();const{origin:n}=r;return v={...t},E=new Promise(s=>{const i=a=>{if(a.origin!==n)return;const{data:o}=a;if(o.type==="init"){s(d.wrap(a.ports[0]));return}if(o.type==="warning"){console[o.level].call(console,o.message);return}};window.addEventListener("message",i)}),document.body.insertBefore(e,null),{serverPromise:E}}function de(t){return typeof t[0]=="string"}function he(t){return t[0]instanceof Uint8Array}function we(){return new URL(window.WEBCONTAINER_API_IFRAME_URL??ee)}function me(){let t=null;return{stream:new ReadableStream({start(n){t=n}}),push:n=>{n!=null?t==null||t.enqueue(n):(t==null||t.close(),t=null)}}}const M={"index.js":{file:{contents:`
import express from 'express';
const app = express();
const port = 3111;
  
app.get('/', (req, res) => {
    res.send('Welcome to a WebContainers app! ðŸ¥³');
});
  
app.listen(port, () => {
    console.log(\`App is live at http://localhost:\${port}\`);
});`}},"package.json":{file:{contents:`
          {
            "name": "example-app",
            "type": "module",
            "dependencies": {
              "express": "latest",
              "nodemon": "latest"
            },
            "scripts": {
              "start": "nodemon index.js"
            }
          }`}}};let y;window.addEventListener("load",async()=>{if(O.value=M["index.js"].file.contents,O.addEventListener("input",e=>{_e(e.currentTarget.value)}),y=await x.boot(),await y.mount(M),await pe()!==0)throw new Error("Installation failed");ye()});async function pe(){const t=await y.spawn("npm",["install"]);return t.output.pipeTo(new WritableStream({write(e){console.log(e)}})),t.exit}async function ye(){await y.spawn("npm",["run","start"]),y.on("server-ready",(t,e)=>{ge.src=e})}async function _e(t){await y.fs.writeFile("/index.js",t)}document.querySelector("#app").innerHTML=`
  <div class="container">
    <div class="editor">
      <textarea>I am a textareas</textarea>
    </div>
    <div class="preview">
      <iframe src="loading.html"></iframe>
    </div>
  </div>
`;window.self===window.top?console.log("window.crossOriginIsolated"+window.crossOriginIsolated):console.log("Damn");const ge=document.querySelector("iframe"),O=document.querySelector("textarea");document.getElementById("info");
